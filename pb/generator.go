package main

import (
	"bytes"
	"fmt"
	"go/format"
	"io/ioutil"
	"log"
	"os"
	"reflect"
	"strings"

	"github.com/xjdrew/daisy/pb/parser"
	"github.com/xjdrew/daisy/pb/rpc"
)

const (
	PkgPathBase     = "github.com/xjdrew/daisy/gen/proto"
	PackageName     = "descriptor"
	ExportedVarname = "Descriptors"
)

type Descriptor struct {
	Id         int32
	NormalName string
	MethodName string
	ArgType    string `type:"expr"`
	ReplyType  string `type:"expr"`
}

func printError(err error, msgs ...string) {
	s := strings.Join(msgs, " ") + ":" + err.Error()
	log.Print("protolist-generator error:", s)
	os.Exit(1)
}

func extractPkg(name string) string {
	if name == "" {
		return ""
	}

	pos1 := strings.Index(name, parser.PathSep)
	pos2 := strings.Index(name, parser.NameSep)
	if pos1 == -1 || pos2 == -1 {
		printError(fmt.Errorf("illegal input name:%s", name), "extractPkg")
	}

	return name[pos1+1 : pos2]
}

func genDependences(modules []parser.Module) []string {
	pkgSet := make(map[string]bool)
	for _, module := range modules {
		for _, service := range module.Services {
			if pkg := extractPkg(service.Input); pkg != "" {
				pkgSet[pkg] = true
			}

			if pkg := extractPkg(service.Output); pkg != "" {
				pkgSet[pkg] = true
			}
		}
	}

	var a []string
	for pkg := range pkgSet {
		a = append(a, pkg)
	}
	return a
}

func genDescriptors(modules []parser.Module) []Descriptor {
	var a []Descriptor
	for _, module := range modules {
		for _, service := range module.Services {
			var d Descriptor
			d.Id = service.Id
			d.NormalName = service.NormalName
			d.MethodName = service.MethodName
			d.ArgType = fmt.Sprintf("reflect.TypeOf(&%s{})", service.Input)
			if service.Output != "" {
				d.ReplyType = fmt.Sprintf("reflect.TypeOf(&%s{})", service.Output)
			} else {
				d.ReplyType = "nil"
			}
			a = append(a, d)
		}
	}
	return a
}

func serializeDescriptor(d Descriptor) string {
	var a []string
	typ := reflect.TypeOf(d)
	v := reflect.ValueOf(d)
	for i := 0; i < typ.NumField(); i++ {
		f := typ.Field(i)
		var str string
		fv := v.FieldByName(f.Name)
		if f.Type.Kind() == reflect.String && f.Tag.Get("type") == "expr" {
			str = fmt.Sprintf("%s:%s", f.Name, fv.String())
		} else {
			str = fmt.Sprintf("%s:%#v", f.Name, fv.Interface())
		}
		a = append(a, str)
	}
	return strings.Join(a, ",\n")
}

func generate(modules []parser.Module) []byte {
	b := new(bytes.Buffer)

	typ := reflect.TypeOf(rpc.Descriptor{})
	arrayTyp := reflect.TypeOf([]rpc.Descriptor{})
	// file header
	b.WriteString("// Code generated by protolist-generator.\n")
	b.WriteString("// DO NOT EDIT!\n")
	b.WriteString("\n")

	// package
	b.WriteString(fmt.Sprintf("package %s\n", PackageName))

	// import
	deps := genDependences(modules)
	b.WriteString("import (\n")
	b.WriteString("\"reflect\"\n")
	b.WriteString("\n")
	b.WriteString(fmt.Sprintf("%q\n", typ.PkgPath()))
	b.WriteString("\n")
	for _, dep := range deps {
		b.WriteString(fmt.Sprintf("\"%s/%s\"", PkgPathBase, dep))
	}
	b.WriteString(")\n")
	b.WriteString("\n")

	// body
	descriptors := genDescriptors(modules)
	b.WriteString(fmt.Sprintf("var %s = %s{", ExportedVarname, arrayTyp.String()))
	for _, dptor := range descriptors {
		b.WriteString("\n")
		b.WriteString(fmt.Sprintf("{\n"))
		b.WriteString(serializeDescriptor(dptor))
		b.WriteString(",\n")
		b.WriteString(fmt.Sprintf("},"))
		b.WriteString("\n")
	}
	b.WriteString("}\n")
	b.WriteString("\n")

	data, err := format.Source(b.Bytes())
	if err != nil {
		printError(err, "format output", b.String())
	}
	return data
}

func main() {
	data, err := ioutil.ReadAll(os.Stdin)
	if err != nil {
		printError(err, "reading input")
	}

	modules, err := parser.ParseData(string(data))
	if err != nil {
		printError(err, "reading input")
	}

	data = generate(modules)
	if _, err = os.Stdout.Write(data); err != nil {
		printError(err, "write output")
	}
}
